


è¨ˆç®—å‡ºç¾æœ€å¤šçš„ç–¾ç—…äººæ•¸


import pandas as pd
# è®€å–ä½ çš„ data.xlsx
df = pd.read_excel("/content/drive/MyDrive/CNNçœ¼ç›è­˜åˆ¥/data.xlsx")
# è¦æª¢æŸ¥çš„ 8 å€‹æ¬„ä½
cols = ["D", "G", "C", "A", "H", "M", "O"]
# è¨ˆç®—æ¯å€‹æ¬„ä½ä¸­ value == 1 çš„æ¬¡æ•¸
count_ones = df[cols].apply(lambda x: (x == 1).sum())
print("å„æ¬„ä½å‡ºç¾ 1 çš„æ¬¡æ•¸ï¼š")
print(count_ones)
# æ‰¾å‡ºå‡ºç¾ 1 æ¬¡æ•¸æœ€å¤šçš„æ¬„ä½
max_col = count_ones.idxmax()
max_val = count_ones.max()
print("\næœ€å¤š 1 çš„æ¬„ä½ï¼š", max_col)
print("æ¬¡æ•¸ï¼š", max_val)




æ›è¼‰ Google Driveã€è¨­å®šè³‡æ–™è·¯å¾‘ã€å»ºç«‹è¼¸å‡ºè³‡æ–™å¤¾


import os
import pandas as pd
from google.colab import drive
# -------------------------------
# æ›è¼‰ Google Drive
# -------------------------------
drive.mount('/content/drive')
# -------------------------------
# è·¯å¾‘è¨­å®š
# -------------------------------
Images_DIR = "/content/drive/MyDrive/CNNçœ¼ç›è­˜åˆ¥/Images"
DATA_PATH = "/content/drive/MyDrive/CNNçœ¼ç›è­˜åˆ¥/data.xlsx"
OUT_Images = "/content/drive/MyDrive/CNNçœ¼ç›è­˜åˆ¥/Processed_Images"
os.makedirs(OUT_Images, exist_ok=True)
for label in [0,1]:
    os.makedirs(os.path.join(OUT_Images, str(label)), exist_ok=True)
print("è³‡æ–™å¤¾å»ºç«‹å®Œæˆ")








è®€å– Excelã€å±•é–‹å·¦å³çœ¼å½±åƒã€æ¨™è¨»é’å…‰çœ¼ (glaucoma)


# -------------------------------
# è®€å– Excel è³‡æ–™
# -------------------------------
df = pd.read_excel(DATA_PATH)
print("åŸå§‹è³‡æ–™ç­†æ•¸ï¼š", len(df))
print(df.head())
# -------------------------------
# å±•é–‹å·¦å³çœ¼ï¼Œæ¯å¼µåœ–ç‰‡ç•¶ä½œä¸€ç­†è³‡æ–™ï¼Œæ¨™è¨» glaucoma
# -------------------------------
rows = []
for _, row in df.iterrows():
    left_label = 1 if "glaucoma" in str(row["Left-Diagnostic Keywords"]).lower() else 0
    rows.append({"filename": row["Left-Fundus"], "label": left_label})
    right_label = 1 if "glaucoma" in str(row["Right-Diagnostic Keywords"]).lower() else 0
    rows.append({"filename": row["Right-Fundus"], "label": right_label})
df_long = pd.DataFrame(rows)
print("å±•é–‹å¾Œè³‡æ–™ç­†æ•¸ï¼š", len(df_long))
print(df_long.head(65))






è£åˆ‡é»‘è‰²é‚Šæ¡†ã€CLAHE å°æ¯”å¢å¼·ã€èª¿æ•´å½±åƒå¤§å°


import cv2
import numpy as np
import os
# -------------------------------
# å‰è™•ç†å‡½å¼
# -------------------------------
def crop_black_circle(img):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if len(contours) == 0:
        return img
    cnt = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(cnt)
    return img[y:y+h, x:x+w]
def apply_CLAHE(img):
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    l = clahe.apply(l)
    merged = cv2.merge((l, a, b))
    return cv2.cvtColor(merged, cv2.COLOR_LAB2BGR)
def preprocess_fundus(input_path, output_path, size=224):
    img = cv2.imread(input_path)
    if img is None:
        print("âš  åœ–ç‰‡è®€å–å¤±æ•—ï¼š", input_path)
        return
    img = crop_black_circle(img)
    img = apply_CLAHE(img)
    img = cv2.resize(img, (size, size))
    cv2.imwrite(output_path, img)
# -------------------------------
# å–®å¼µåœ–ç‰‡è™•ç†å‡½å¼
# -------------------------------
def process_file(row):
    fname = row["filename"]
    label = str(row["label"])
    src_path = os.path.join(Images_DIR, fname)
    dst_path = os.path.join(OUT_Images, label, fname)
    if not os.path.exists(src_path):
        print("âš  åœ–ç‰‡ä¸å­˜åœ¨:", src_path)
        return None
    preprocess_fundus(src_path, dst_path)
    return fname
import cv2
import numpy as np
import os
# -------------------------------
# å‰è™•ç†å‡½å¼
# -------------------------------
def crop_black_circle(img):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if len(contours) == 0:
        return img
    cnt = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(cnt)
    return img[y:y+h, x:x+w]
def apply_CLAHE(img):
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    l = clahe.apply(l)
    merged = cv2.merge((l, a, b))
    return cv2.cvtColor(merged, cv2.COLOR_LAB2BGR)
def preprocess_fundus(input_path, output_path, size=224):
    img = cv2.imread(input_path)
    if img is None:
        print("âš  åœ–ç‰‡è®€å–å¤±æ•—ï¼š", input_path)
        return
    img = crop_black_circle(img)
    img = apply_CLAHE(img)
    img = cv2.resize(img, (size, size))
    cv2.imwrite(output_path, img)
# -------------------------------
# å–®å¼µåœ–ç‰‡è™•ç†å‡½å¼
# -------------------------------
def process_file(row):
    fname = row["filename"]
    label = str(row["label"])
    src_path = os.path.join(Images_DIR, fname)
    dst_path = os.path.join(OUT_Images, label, fname)
    if not os.path.exists(src_path):
        print("âš  åœ–ç‰‡ä¸å­˜åœ¨:", src_path)
        return None
    preprocess_fundus(src_path, dst_path)
    return fname




åˆ†æ‰¹è™•ç†å½±åƒï¼Œä½¿ç”¨ ThreadPoolExecutor åŠ é€Ÿå‰è™•ç†ï¼Œ1/0åˆ†è³‡æ–™å¤¾


import time
from concurrent.futures import ThreadPoolExecutor
# -------------------------------
# æ‰¹æ¬¡è™•ç†å‡½å¼
# -------------------------------
BATCH_SIZE = 500
NUM_WORKERS = 8
def batch_process(df_subset, dataset_name="dataset"):
    total_files = len(df_subset)
    if total_files == 0:
        print(f"âŒ {dataset_name} ç„¡è³‡æ–™å¯è™•ç†ï¼")
        return
    start_time = time.time()
    for start_idx in range(0, total_files, BATCH_SIZE):
        end_idx = min(start_idx + BATCH_SIZE, total_files)
        batch_rows = df_subset.iloc[start_idx:end_idx]
        batch_start = time.time()
        print(f"\nğŸ“¦ è™•ç† {dataset_name} ç¬¬ {start_idx+1}-{end_idx} å¼µåœ–ç‰‡...")
        with ThreadPoolExecutor(max_workers=NUM_WORKERS) as executor:
            for global_idx, _ in enumerate(executor.map(process_file,
                                                         [row for _, row in batch_rows.iterrows()]),
                                           start=start_idx+1):
                elapsed = time.time() - start_time
                processed = global_idx
                remaining = total_files - processed
                eta = elapsed / processed * remaining if processed > 0 else 0
                print(f"è™•ç†ä¸­ï¼š{global_idx}/{total_files} ({global_idx/total_files*100:.1f}%) - ETA {eta/60:.1f} åˆ†é˜", end="\r")
        batch_elapsed = time.time() - batch_start
        print(f"\nâœ… æœ¬æ‰¹å®Œæˆï¼Œç”¨æ™‚ {batch_elapsed:.1f} ç§’")
    total_elapsed = time.time() - start_time
    print(f"\nğŸ‰ {dataset_name} å…¨éƒ¨åœ–ç‰‡å‰è™•ç†å®Œæˆï¼ç¸½ç”¨æ™‚ {total_elapsed/60:.1f} åˆ†é˜")
# -------------------------------
# åŸ·è¡Œæ‰¹æ¬¡è™•ç†
# -------------------------------
print("é–‹å§‹è™•ç†å…¨éƒ¨è³‡æ–™...")
batch_process(df_long, dataset_name="all images")




ç¢ºå®š1/0åˆ†è³‡æ–™å¤¾è£¡å€‹æ•¸


import os
# è¨­å®šè·¯å¾‘
base_path = "/content/drive/MyDrive/CNNçœ¼ç›è­˜åˆ¥/Processed_Images"
folders = ["0", "1"]
print(f"ğŸ“‚ æ­£åœ¨çµ±è¨ˆè·¯å¾‘ï¼š{base_path}\n")
total_count = 0
for folder in folders:
    folder_path = os.path.join(base_path, folder)
    if os.path.exists(folder_path):
        # åªè¨ˆç®—å¸¸è¦‹çš„åœ–ç‰‡æ ¼å¼
        files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
        count = len(files)
        total_count += count
        label_name = "æ­£å¸¸ (Normal)" if folder == "0" else "é’å…‰çœ¼ (Glaucoma)"
        print(f"ğŸ“ è³‡æ–™å¤¾ ã€{folder}ã€‘ ({label_name})")
        print(f"   â””â”€â”€ åœ–ç‰‡æ•¸é‡ï¼š{count} ç­†")
    else:
        print(f"âŒ æ‰¾ä¸åˆ°è³‡æ–™å¤¾ï¼š{folder_path}")
print("-" * 30)
print(f"ç¸½è¨ˆåœ–ç‰‡ç¸½æ•¸ï¼š{total_count} ç­†")


